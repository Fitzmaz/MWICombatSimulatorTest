{"version":3,"file":"src_multiWorker_js.bundle.js","mappings":";;;UAAA;UACA;;UAEA;UACA;;;;;WCJA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;;WAEA;;WAEA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD,gEAAgE,2FAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,2DAA2D,sDAAsD;AACjH,8BAA8B;AAC9B;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA,mCAAmC,mEAAmE;AACtG,cAAc;AACd;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA,E","sources":["webpack://mwicombatsimulator/webpack/bootstrap","webpack://mwicombatsimulator/webpack/runtime/get javascript chunk filename","webpack://mwicombatsimulator/webpack/runtime/global","webpack://mwicombatsimulator/webpack/runtime/hasOwnProperty shorthand","webpack://mwicombatsimulator/webpack/runtime/publicPath","webpack://mwicombatsimulator/webpack/runtime/importScripts chunk loading","webpack://mwicombatsimulator/./src/multiWorker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_multiWorker_js\": 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","\r\nonmessage = async function (event) {\r\n    switch (event.data.type) {\r\n        case \"start_simulation_all_zones\":\r\n            // get now time\r\n            const now = new Date();\r\n            const zoneHrids = event.data.zones;\r\n            let zoneProgress = {};\r\n\r\n            try {\r\n                const simulatorWorkerPool = []\r\n                for (let i = 0; i < zoneHrids.length; i++) {\r\n                    const simulationWorker = new Worker(new URL('worker.js', import.meta.url));\r\n                    simulatorWorkerPool.push(simulationWorker);\r\n                    // Do simulation\r\n                    let workerMessage = {\r\n                        type: \"start_simulation\",\r\n                        players: event.data.players,\r\n                        zoneHrid: zoneHrids[i],\r\n                        simulationTimeLimit: event.data.simulationTimeLimit,\r\n                    };\r\n                    simulationWorker.postMessage(workerMessage);\r\n                }\r\n\r\n                const outer_worker = this;\r\n                // Wait for all simulations to finish\r\n                const simulationResults = await Promise.all(simulatorWorkerPool.map(worker => {\r\n                    return new Promise((resolve, reject) => {\r\n                        worker.onmessage = function (event) {\r\n                            if (event.data.type === \"simulation_result\") {\r\n                                resolve(event.data.simResult);\r\n                            } else if (event.data.type === \"simulation_progress\") {\r\n                                zoneProgress[event.data.zone] = event.data.progress;\r\n                                let totalProgress = Object.values(zoneProgress).reduce((acc, progress) => acc + progress, 0) / Object.keys(zoneProgress).length;\r\n                                outer_worker.postMessage({ type: \"simulation_progress\", progress: totalProgress });\r\n                            } else if (event.data.type === \"simulation_error\") {\r\n                                reject(event.data.error);\r\n                            }\r\n                        };\r\n                    });\r\n                }));\r\n\r\n                // Terminate all workers\r\n                for (let i = 0; i < simulatorWorkerPool.length; i++) {\r\n                    simulatorWorkerPool[i].terminate();\r\n                }\r\n\r\n                this.postMessage({ type: \"simulation_result_allZones\", simResults: simulationResults });\r\n            } catch (e) {\r\n                console.log(e);\r\n                this.postMessage({ type: \"simulation_error\", error: e });\r\n            }\r\n            break;\r\n    }\r\n};"],"names":[],"sourceRoot":""}