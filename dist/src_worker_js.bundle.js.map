{"version":3,"file":"src_worker_js.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAA0B;AAC4B;AACtB;;AAEhC;AACA;AACA;;AAEA,6BAA6B,qDAAa;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD,gDAAO;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtF4B;AACmD;;AAEzG;AACA;AACA;AACA,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,iFAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;ACvCC;AACsC;;AAEhE;AACA;AACA;AACA;;AAEA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;;;AC7BQ;AACM;AACA;AACF;AACA;;AAEpC,qBAAqB,mDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,kDAAS;AACrD;;AAEA,qDAAqD,mDAAU;AAC/D,2DAA2D,mDAAU;AACrE,qEAAqE,gDAAO;AAC5E;AACA;AACA,2CAA2C,kDAAS;AACpD;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;AC5JoC;AAC1B;;AAEhC;AACA;AACA;;AAEA,uBAAuB,uDAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yEAAyE,gDAAO;AAChF;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,yDAAyD;AACxF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,+DAA+D;AAC7G,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gDAAO;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gDAAO;AAC/D,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,iCAAiC;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,+DAA+D;AACjH,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gDAAO;AAC3D;AACA;AACA;;AAEA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;AC9G4C;AAClB;AACJ;;;AAG1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,cAAc;AACd;AACA,4BAA4B,sBAAsB;AAClD,4DAA4D,2FAAqD;AACjH;AACA;;AAEA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA,4BAA4B,gCAAgC;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAI;AAC/B,4BAA4B,wBAAwB;AACpD,oCAAoC,+DAAM;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,wEAAe;AACrD;AACA,mCAAmC,qDAAqD;AACxF,aAAa;;AAEb;AACA;AACA,mCAAmC,iDAAiD;AACpF,cAAc;AACd;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,sBAAsB;AAClD,yCAAyC,6DAAI;AAC7C;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D,4CAA4C,+DAAM;AAClD;AACA;AACA;AACA,yCAAyC,wEAAe;AACxD;AACA;AACA;;AAEA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA,uCAAuC,uDAAuD;AAC9F,iBAAiB;AACjB;;AAEA;AACA;AACA,uCAAuC,4DAA4D;AACnG,kBAAkB;AAClB;AACA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA;;;;;;;UC/HA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;UENA;UACA","sources":["webpack://mwicombatsimulator/./src/combatsimulator/consumable.js","webpack://mwicombatsimulator/./src/combatsimulator/equipment.js","webpack://mwicombatsimulator/./src/combatsimulator/houseRoom.js","webpack://mwicombatsimulator/./src/combatsimulator/player.js","webpack://mwicombatsimulator/./src/combatsimulator/zone.js","webpack://mwicombatsimulator/./src/worker.js","webpack://mwicombatsimulator/webpack/bootstrap","webpack://mwicombatsimulator/webpack/runtime/chunk loaded","webpack://mwicombatsimulator/webpack/runtime/define property getters","webpack://mwicombatsimulator/webpack/runtime/ensure chunk","webpack://mwicombatsimulator/webpack/runtime/get javascript chunk filename","webpack://mwicombatsimulator/webpack/runtime/global","webpack://mwicombatsimulator/webpack/runtime/hasOwnProperty shorthand","webpack://mwicombatsimulator/webpack/runtime/make namespace object","webpack://mwicombatsimulator/webpack/runtime/publicPath","webpack://mwicombatsimulator/webpack/runtime/importScripts chunk loading","webpack://mwicombatsimulator/webpack/runtime/startup chunk dependencies","webpack://mwicombatsimulator/webpack/before-startup","webpack://mwicombatsimulator/webpack/startup","webpack://mwicombatsimulator/webpack/after-startup"],"sourcesContent":["import Buff from \"./buff\";\nimport itemDetailMap from \"./data/itemDetailMap.json\";\nimport Trigger from \"./trigger\";\n\nclass Consumable {\n    constructor(hrid, triggers = null) {\n        this.hrid = hrid;\n\n        let gameConsumable = itemDetailMap[this.hrid];\n        if (!gameConsumable) {\n            throw new Error(\"No consumable found for hrid: \" + this.hrid);\n        }\n\n        this.cooldownDuration = gameConsumable.consumableDetail.cooldownDuration;\n        this.hitpointRestore = gameConsumable.consumableDetail.hitpointRestore;\n        this.manapointRestore = gameConsumable.consumableDetail.manapointRestore;\n        this.recoveryDuration = gameConsumable.consumableDetail.recoveryDuration;\n        this.catagoryHrid = gameConsumable.categoryHrid;\n\n        this.buffs = [];\n        if (gameConsumable.consumableDetail.buffs) {\n            for (const consumableBuff of gameConsumable.consumableDetail.buffs) {\n                let buff = new Buff(consumableBuff);\n                this.buffs.push(buff);\n            }\n        }\n\n        if (triggers) {\n            this.triggers = triggers;\n        } else {\n            this.triggers = [];\n            for (const defaultTrigger of gameConsumable.consumableDetail.defaultCombatTriggers) {\n                let trigger = new Trigger(\n                    defaultTrigger.dependencyHrid,\n                    defaultTrigger.conditionHrid,\n                    defaultTrigger.comparatorHrid,\n                    defaultTrigger.value\n                );\n                this.triggers.push(trigger);\n            }\n        }\n\n        this.lastUsed = Number.MIN_SAFE_INTEGER;\n    }\n\n    static createFromDTO(dto) {\n        let triggers = dto.triggers.map((trigger) => Trigger.createFromDTO(trigger));\n        let consumable = new Consumable(dto.hrid, triggers);\n\n        return consumable;\n    }\n\n    shouldTrigger(currentTime, source, target, friendlies, enemies) {\n        if (source.isStunned) {\n            return false;\n        }\n        let consumableHaste;\n        if (this.catagoryHrid.includes(\"food\")) {\n            consumableHaste = source.combatDetails.combatStats.foodHaste\n        } else {\n            consumableHaste = source.combatDetails.combatStats.drinkConcentration;\n        }\n        let cooldownDuration = this.cooldownDuration;\n        if (consumableHaste > 0) {\n            cooldownDuration = cooldownDuration / (1 + consumableHaste);\n        }\n\n        if (this.lastUsed + cooldownDuration > currentTime) {\n            return false;\n        }\n\n        if (this.triggers.length == 0) {\n            return true;\n        }\n\n        let shouldTrigger = true;\n        for (const trigger of this.triggers) {\n            if (!trigger.isActive(source, target, friendlies, enemies, currentTime)) {\n                shouldTrigger = false;\n            }\n        }\n\n        return shouldTrigger;\n    }\n}\n\nexport default Consumable;\n","import itemDetailMap from \"./data/itemDetailMap.json\";\nimport enhancementLevelTotalMultiplierTable from \"./data/enhancementLevelTotalBonusMultiplierTable.json\";\n\nclass Equipment {\n    constructor(hrid, enhancementLevel) {\n        this.hrid = hrid;\n        let gameItem = itemDetailMap[this.hrid];\n        if (!gameItem) {\n            throw new Error(\"No equipment found for hrid: \" + this.hrid);\n        }\n        this.gameItem = gameItem;\n        this.enhancementLevel = enhancementLevel;\n    }\n\n    static createFromDTO(dto) {\n        let equipment = new Equipment(dto.hrid, dto.enhancementLevel);\n\n        return equipment;\n    }\n\n    getCombatStat(combatStat) {\n        let multiplier = enhancementLevelTotalMultiplierTable[this.enhancementLevel];\n        if(this.gameItem.equipmentDetail.combatStats[combatStat]) {\n            let enhancementBonus = this.gameItem.equipmentDetail.combatEnhancementBonuses[combatStat] || 0;\n            let stat = this.gameItem.equipmentDetail.combatStats[combatStat] + multiplier * enhancementBonus;\n            return stat;\n        }\n        return 0;\n    }\n\n    getCombatStyle() {\n        return this.gameItem.equipmentDetail.combatStats.combatStyleHrids[0];\n    }\n\n    getDamageType() {\n        return this.gameItem.equipmentDetail.combatStats.damageType;\n    }\n}\n\nexport default Equipment;\n","import Buff from \"./buff\";\nimport houseRoomDetailMap from \"./data/houseRoomDetailMap.json\";\n\nclass HouseRoom {\n    constructor(hrid, level) {\n        this.hrid = hrid;\n        this.level = level;\n\n        let gameHouseRoom = houseRoomDetailMap[this.hrid];\n        if (!gameHouseRoom) {\n            throw new Error(\"No house room found for hrid: \" + this.hrid);\n        }\n\n        this.buffs = [];\n        if (gameHouseRoom.actionBuffs) {\n            for (const actionBuff of gameHouseRoom.actionBuffs) {\n                let buff = new Buff(actionBuff, level);\n                this.buffs.push(buff);\n            }\n        }\n        if (gameHouseRoom.globalBuffs) {\n            for (const globalBuff of gameHouseRoom.globalBuffs) {\n                let buff = new Buff(globalBuff, level);\n                this.buffs.push(buff);\n            }\n        }\n    }\n}\n\nexport default HouseRoom;","import Ability from \"./ability\";\nimport CombatUnit from \"./combatUnit\";\nimport Consumable from \"./consumable\";\nimport Equipment from \"./equipment\";\nimport HouseRoom from \"./houseRoom\";\n\nclass Player extends CombatUnit {\n    equipment = {\n        \"/equipment_types/head\": null,\n        \"/equipment_types/body\": null,\n        \"/equipment_types/legs\": null,\n        \"/equipment_types/feet\": null,\n        \"/equipment_types/hands\": null,\n        \"/equipment_types/main_hand\": null,\n        \"/equipment_types/two_hand\": null,\n        \"/equipment_types/off_hand\": null,\n        \"/equipment_types/pouch\": null,\n        \"/equipment_types/back\": null,\n    };\n\n    constructor() {\n        super();\n\n        this.isPlayer = true;\n        this.hrid = \"player\";\n    }\n\n    static createFromDTO(dto) {\n        let player = new Player();\n\n        player.staminaLevel = dto.staminaLevel;\n        player.intelligenceLevel = dto.intelligenceLevel;\n        player.attackLevel = dto.attackLevel;\n        player.powerLevel = dto.powerLevel;\n        player.defenseLevel = dto.defenseLevel;\n        player.rangedLevel = dto.rangedLevel;\n        player.magicLevel = dto.magicLevel;\n        player.hrid = dto.hrid;\n\n        for (const [key, value] of Object.entries(dto.equipment)) {\n            player.equipment[key] = value ? Equipment.createFromDTO(value) : null;\n        }\n\n        player.food = dto.food.map((food) => (food ? Consumable.createFromDTO(food) : null));\n        player.drinks = dto.drinks.map((drink) => (drink ? Consumable.createFromDTO(drink) : null));\n        player.abilities = dto.abilities.map((ability) => (ability ? Ability.createFromDTO(ability) : null));\n        Object.entries(dto.houseRooms).forEach(houseRoom => {\n            if (houseRoom[1] > 0) {\n                player.houseRooms.push(new HouseRoom(houseRoom[0], houseRoom[1]))\n            }\n        });\n\n        return player;\n    }\n\n    updateCombatDetails() {\n        if (this.equipment[\"/equipment_types/main_hand\"]) {\n            this.combatDetails.combatStats.combatStyleHrid =\n                this.equipment[\"/equipment_types/main_hand\"].getCombatStyle();\n            this.combatDetails.combatStats.damageType = this.equipment[\"/equipment_types/main_hand\"].getDamageType();\n            this.combatDetails.combatStats.attackInterval =\n                this.equipment[\"/equipment_types/main_hand\"].getCombatStat(\"attackInterval\");\n        } else if (this.equipment[\"/equipment_types/two_hand\"]) {\n            this.combatDetails.combatStats.combatStyleHrid =\n                this.equipment[\"/equipment_types/two_hand\"].getCombatStyle();\n            this.combatDetails.combatStats.damageType = this.equipment[\"/equipment_types/two_hand\"].getDamageType();\n            this.combatDetails.combatStats.attackInterval =\n                this.equipment[\"/equipment_types/two_hand\"].getCombatStat(\"attackInterval\");\n        } else {\n            this.combatDetails.combatStats.combatStyleHrid = \"/combat_styles/smash\";\n            this.combatDetails.combatStats.damageType = \"/damage_types/physical\";\n            this.combatDetails.combatStats.attackInterval = 3000000000;\n        }\n\n        [\n            \"stabAccuracy\",\n            \"slashAccuracy\",\n            \"smashAccuracy\",\n            \"rangedAccuracy\",\n            \"magicAccuracy\",\n            \"stabDamage\",\n            \"slashDamage\",\n            \"smashDamage\",\n            \"rangedDamage\",\n            \"magicDamage\",\n            \"taskDamage\",\n            \"physicalAmplify\",\n            \"waterAmplify\",\n            \"natureAmplify\",\n            \"fireAmplify\",\n            \"healingAmplify\",\n            \"stabEvasion\",\n            \"slashEvasion\",\n            \"smashEvasion\",\n            \"rangedEvasion\",\n            \"magicEvasion\",\n            \"armor\",\n            \"waterResistance\",\n            \"natureResistance\",\n            \"fireResistance\",\n            \"maxHitpoints\",\n            \"maxManapoints\",\n            \"lifeSteal\",\n            \"hpRegenPer10\",\n            \"mpRegenPer10\",\n            \"physicalThorns\",\n            \"elementalThorns\",\n            \"combatDropRate\",\n            \"combatRareFind\",\n            \"combatDropQuantity\",\n            \"combatExperience\",\n            \"criticalRate\",\n            \"criticalDamage\",\n            \"armorPenetration\",\n            \"waterPenetration\",\n            \"naturePenetration\",\n            \"firePenetration\",\n            \"abilityHaste\",\n            \"tenacity\",\n            \"manaLeech\",\n            \"castSpeed\",\n            \"threat\",\n            \"parry\",\n            \"mayhem\",\n            \"pierce\",\n            \"curse\",\n            \"fury\",\n            \"weaken\",\n            \"ripple\",\n            \"bloom\",\n            \"blaze\",\n            \"attackSpeed\",\n            \"foodHaste\",\n            \"drinkConcentration\",\n            \"autoAttackDamage\"\n        ].forEach((stat) => {\n            this.combatDetails.combatStats[stat] = Object.values(this.equipment)\n                .filter((equipment) => equipment != null)\n                .map((equipment) => equipment.getCombatStat(stat))\n                .reduce((prev, cur) => prev + cur, 0);\n        });\n\n        if (this.equipment[\"/equipment_types/pouch\"]) {\n            this.combatDetails.combatStats.foodSlots =\n                1 + this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"foodSlots\");\n            this.combatDetails.combatStats.drinkSlots =\n                1 + this.equipment[\"/equipment_types/pouch\"].getCombatStat(\"drinkSlots\");\n        } else {\n            this.combatDetails.combatStats.foodSlots = 1;\n            this.combatDetails.combatStats.drinkSlots = 1;\n        }\n\n        super.updateCombatDetails();\n    }\n}\n\nexport default Player;\n","import actionDetailMap from \"./data/actionDetailMap.json\";\nimport Monster from \"./monster\";\n\nclass Zone {\n    constructor(hrid) {\n        this.hrid = hrid;\n\n        let gameZone = actionDetailMap[this.hrid];\n        this.monsterSpawnInfo = gameZone.combatZoneInfo.fightInfo;\n        this.dungeonSpawnInfo = gameZone.combatZoneInfo.dungeonInfo;\n        this.encountersKilled = 1;\n        this.monsterSpawnInfo.battlesPerBoss = 10;\n        this.buffs = gameZone.buffs;\n        this.isDungeon = gameZone.combatZoneInfo.isDungeon;\n        this.dungeonsCompleted = 0;\n        this.dungeonsFailed = 0;\n        this.finalWave = false;\n    }\n\n    getRandomEncounter() {\n\n        if (this.monsterSpawnInfo.bossSpawns && this.encountersKilled == this.monsterSpawnInfo.battlesPerBoss) {\n            this.encountersKilled = 1;\n            return this.monsterSpawnInfo.bossSpawns.map((monster) => new Monster(monster.combatMonsterHrid, monster.eliteTier));\n        }\n\n        let totalWeight = this.monsterSpawnInfo.randomSpawnInfo.spawns.reduce((prev, cur) => prev + cur.rate, 0);\n\n        let encounterHrids = [];\n        let totalStrength = 0;\n\n        outer: for (let i = 0; i < this.monsterSpawnInfo.randomSpawnInfo.maxSpawnCount; i++) {\n            let randomWeight = totalWeight * Math.random();\n            let cumulativeWeight = 0;\n\n            for (const spawn of this.monsterSpawnInfo.randomSpawnInfo.spawns) {\n                cumulativeWeight += spawn.rate;\n                if (randomWeight <= cumulativeWeight) {\n                    totalStrength += spawn.strength;\n\n                    if (totalStrength <= this.monsterSpawnInfo.randomSpawnInfo.maxTotalStrength) {\n                        encounterHrids.push({ 'hrid': spawn.combatMonsterHrid, 'eliteTier': spawn.eliteTier });\n                    } else {\n                        break outer;\n                    }\n                    break;\n                }\n            }\n        }\n        this.encountersKilled++;\n        return encounterHrids.map((hrid) => new Monster(hrid.hrid, hrid.eliteTier));\n    }\n\n    failWave() {\n        this.dungeonsFailed++;\n        this.encountersKilled = 1;\n    }\n\n    getNextWave() {\n        if (this.encountersKilled > this.dungeonSpawnInfo.maxWaves) {\n            this.dungeonsCompleted++;\n            this.encountersKilled = 1;\n        }\n        // console.log(\"Wave #\" + this.encountersKilled);\n        if (this.dungeonSpawnInfo.fixedSpawnsMap.hasOwnProperty(this.encountersKilled.toString())) {\n            let currentMonsters = this.dungeonSpawnInfo.fixedSpawnsMap[(this.encountersKilled).toString()];\n            this.encountersKilled++;\n            return currentMonsters.map((monster) => new Monster(monster.combatMonsterHrid, monster.eliteTier));\n        } else {\n            let monsterSpawns = {};\n            const waveKeys = Object.keys(this.dungeonSpawnInfo.randomSpawnInfoMap).map(Number).sort((a, b) => a - b);\n            if (this.encountersKilled > waveKeys[waveKeys.length - 1]) {\n                monsterSpawns = this.dungeonSpawnInfo.randomSpawnInfoMap[waveKeys[waveKeys.length - 1]];\n            } else {\n                for (let i = 0; i < waveKeys.length - 1; i++) {\n                    if (this.encountersKilled >= waveKeys[i] && this.encountersKilled <= waveKeys[i + 1]) {\n                        monsterSpawns = this.dungeonSpawnInfo.randomSpawnInfoMap[waveKeys[i]];\n                        break;\n                    }\n                }\n            }\n            let totalWeight = monsterSpawns.spawns.reduce((prev, cur) => prev + cur.rate, 0);\n\n            let encounterHrids = [];\n            let totalStrength = 0;\n\n            outer: for (let i = 0; i < monsterSpawns.maxSpawnCount; i++) {\n                let randomWeight = totalWeight * Math.random();\n                let cumulativeWeight = 0;\n\n                for (const spawn of monsterSpawns.spawns) {\n                    cumulativeWeight += spawn.rate;\n                    if (randomWeight <= cumulativeWeight) {\n                        totalStrength += spawn.strength;\n\n                        if (totalStrength <= monsterSpawns.maxTotalStrength) {\n                            encounterHrids.push({ 'hrid': spawn.combatMonsterHrid, 'eliteTier': spawn.eliteTier });\n                        } else {\n                            break outer;\n                        }\n                        break;\n                    }\n                }\n            }\n            this.encountersKilled++;\n            return encounterHrids.map((hrid) => new Monster(hrid.hrid, hrid.eliteTier));\n        }\n    }\n}\n\nexport default Zone;\n","import CombatSimulator from \"./combatsimulator/combatSimulator\";\nimport Player from \"./combatsimulator/player\";\nimport Zone from \"./combatsimulator/zone\";\n\n\nclass SimulationManager {\n    constructor() {\n        this.simulations = [];\n        this.simResults;\n        this.threadLimit = 10;\n    }\n\n    addSimulation(sim) {\n        this.simulations.push(sim);\n    }\n\n    async startSimulations(simulationTimeLimit) {\n        if (this.simulations.length === 1 || this.threadLimit === 1) {\n            const simulationPromises = this.simulations.map(simulation => simulation.simulate(simulationTimeLimit));\n            const results = await Promise.all(simulationPromises);\n            return results;\n        }else{\n            // Create thread pool for all-simulation senario\n            const simulatorMessages = this.simulations.map(simulation => { return {\n                type: \"start_simulation\",\n                simulator: simulation,\n                simulationTimeLimit: simulationTimeLimit,\n            }});\n            const simulatorWorkerPool = []\n            for (let i = 0; i < this.threadLimit; i++) {\n                const simulationWorker = new Worker(new URL('combatsimulator/combatSimulator.js', import.meta.url));\n                simulatorWorkerPool.push(simulationWorker);\n            }\n\n            // Do simulation\n            for (let i = 0; i < simulatorMessages.length; i++) {\n                const workerIndex = i % this.threadLimit;\n                simulatorWorkerPool[workerIndex].postMessage(simulatorMessages[i]);\n            }\n\n            // Wait for all simulations to finish\n            const simulationResults = await Promise.all(simulatorWorkerPool.map(worker => {\n                return new Promise((resolve, reject) => {\n                    worker.onmessage = function (event) {\n                        if (event.data.type === \"simulation_result\") {\n                            resolve(event.data.simResult);\n                        } else if (event.data.type === \"simulation_error\") {\n                            reject(event.data.error);\n                        }\n                    };\n                });\n            }));\n\n            // Terminate all workers\n            for (let i = 0; i < simulatorWorkerPool.length; i++) {\n                simulatorWorkerPool[i].terminate();\n            }\n\n            return simulationResults;\n        }\n    }\n}\n\nonmessage = async function (event) {\n    switch (event.data.type) {\n        case \"start_simulation\":\n            let playersData = event.data.players;\n            let players = [];\n            let zone = new Zone(event.data.zoneHrid);\n            for (let i = 0; i < playersData.length; i++) {\n                let currentPlayer = Player.createFromDTO(structuredClone(playersData[i]));\n                currentPlayer.zoneBuffs = zone.buffs;\n                players.push(currentPlayer);\n            }\n            let simulationTimeLimit = event.data.simulationTimeLimit;\n            let combatSimulator = new CombatSimulator(players, zone);\n            combatSimulator.addEventListener(\"progress\", (event) => {\n                this.postMessage({ type: \"simulation_progress\", progress: event.detail });\n            });\n\n            try {\n                let simResult = await combatSimulator.simulate(simulationTimeLimit);\n                this.postMessage({ type: \"simulation_result\", simResult: simResult });\n            } catch (e) {\n                console.log(e);\n                this.postMessage({ type: \"simulation_error\", error: e });\n            }\n            break;\n        case \"start_simulation_all_zones\":\n            const simManager = new SimulationManager();\n            const zoneHrids = event.data.zones;\n            let nowSimulationTime = {};\n\n            for (let i = 0; i < zoneHrids.length; i++) {\n                const zoneInstance = new Zone(zoneHrids[i]);\n                if (zoneInstance.monsterSpawnInfo.randomSpawnInfo.spawns) {\n                    let players = [];\n                    let playersData = event.data.players;\n                    for (let i = 0; i < playersData.length; i++) {\n                        let currentPlayer = Player.createFromDTO(structuredClone(playersData[i]));\n                        currentPlayer.zoneBuffs = zoneInstance.buffs;\n                        players.push(currentPlayer);\n                    }\n                    let simulation = new CombatSimulator(players, zoneInstance);\n                    simManager.addSimulation(simulation);\n                }\n            }\n\n            // Add progress listener for each simulation\n            for (let i = 0; i < simManager.simulations.length; i++) {\n                const simulation = simManager.simulations[i];\n                simulation.addEventListener(\"progress\", (event) => {\n                    nowSimulationTime[event.zone.hrid] = event.progress;\n                    total_progress = Object.values(nowSimulationTime).reduce((a, b) => a + b, 0) / simManager.simulations.length;\n                    this.postMessage({ type: \"simulation_progress\", progress: total_progress });\n                });\n            }\n\n            try {\n                const simResults = await simManager.startSimulations(event.data.simulationTimeLimit);\n                    this.postMessage({ type: \"simulation_result_allZones\", simResults: simResults });\n                } catch (e) {\n                    console.log(e);\n                    this.postMessage({ type: \"simulation_error\", error: e });\n                }\n            break;\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_heap-js_dist_heap-js_es5_js\",\"src_combatsimulator_combatSimulator_js\"], () => (__webpack_require__(\"./src/worker.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_worker_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkmwicombatsimulator\"] = self[\"webpackChunkmwicombatsimulator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(\"vendors-node_modules_heap-js_dist_heap-js_es5_js\"),\n\t\t__webpack_require__.e(\"src_combatsimulator_combatSimulator_js\")\n\t]).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}